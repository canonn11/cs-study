# 선형 자료구조

## 연결 리스트(Linked List)

- 데이터를 감싼 노드를 포인터로 연결함.
- 삽입, 삭제에 O(1)이 걸리며(위치를 이미 알고 있는 노드를 삽입,삭제하는 경우) 탐색은 O(n)
- prev, next 포인터를 모두 가지면 Doubly Linked List, next포인터만 가지면 Singly Linked List임.

![Untitled](https://user-images.githubusercontent.com/51450093/188276091-a5ec589e-8ec6-42c1-b1c3-b163c58f57cf.png)

- Doubly Linked List를 주로 사용함. 장단점 아래에서 설명
- 장점 : 노드가 양방향으로 연결되어 있기 때문에 양방향으로 이동하며 탐색이 가능함, 탐색 시간을 줄일 수 있음
- 단점 : 구현이 복잡하고, prev포인터를 저장하기 위한 변수를 하나 더 사용하므로 메모리를 더 많이 사용함

## 배열(Array)

- 같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며 인접한 메모리 위치에 있는 데이터들을 모아놓은 집합
- 데이터간의 중복을 허용하며, 순서가 존재함
- 순차적으로 접근해야 하는 Linked List와는 다르게, 인덱스를 기반으로 랜덤 접근(Random Access)이 가능함

![Untitled 1](https://user-images.githubusercontent.com/51450093/188276054-a52920d3-5e79-42f5-a269-3b7c156ecda3.png)

- 탐색에 O(1), 삽입, (각 데이터마다 인덱스가 존재하기 때문에 그냥 접근하면 된다) 삽입,삭제에 O(n) 소요. (중간에 데이터를 넣고자 하면 그 이후의 데이터를 전부 한칸씩 밀어야하고, 중간걸 삭제하고자 하면 그 이후의 데이터를 전부 한칸씩 땡겨야함)

## Linked List와 Array의 비교

- 연결리스트는 삽입, 삭제가 빠르고(O(1)), 탐색이 느림(O(n))
- 배열은 탐색이 빠르고(O(1)), 삽입, 삭제가 느림(O(n))
- 데이터 추가, 삭제가 많은 경우에는 연결 리스트가 적합하고(앞뒤로 prev, next 포인터만 변경해 주면 되기 때문에) 탐색이 많은 것은 배열이 적합함(인덱스로 빠른 접근이 가능하기 때문, 연결리스트는 처음부터 순차적으로 찾아야함)

## 벡터(Vector)

- 요소를 동적으로 할당할 수 있는 배열. 컴파일 시점에 데이터의 개수나 크기를 알기 어렵다면 벡터를 사용해야 함. (배열의 크기는 한번 정해지면 고정이기 때문에)
- 배열과 마찬가지로 랜덤 접근이 가능하기 때문에 탐색은 O(1)
- 마지막 요소를 삽입이나 삭제하는 데는 O(1)이지만, 중간의 요소를 삽입하고 배열과 동일하게 삭제하는 데에는 O(n)
- 배열과 비교했을 때 저장하고자 하는 데이터 개수가 가변적이고, 중간 데이터를 바꿀일 없이 마지막에만 추가, 삭제를 주로 하는 경우에 사용하면 효율적

# 스택(Stack)

- 가장 마지막으로 들어간 데이터가 가장 처음으로 나오는 것이 특징(LIFO)
- 재귀함수, 알고리즘 등에 사용되며 웹브라우저의 방문 기록 등을 구현하는 데 사용
- 중간에 데이터를 바로 넣거나 빼는것이 기본적으로 불가능하므로 최상단의 데이터 삽입 삭제만 가능하기 때문에, 삽입, 삭제는 O(1), 탐색에는 O(n)이 소요됨

# 큐(Queue)

- 스택과 반대로, 먼저 넣은 데이터가 먼저 나오는 것이 특징임(FIFO)
- 프로세스 스케줄러, 캐시 등을 구현하는 데에 사용됨
- 스택과 마찬가지로 중간에 삽입, 삭제가 불가능하기 때문에 삽입, 삭제에 O(1), 탐색에 O(n) 소요됨
-
