# 비선형 자료구조

## 그래프

- 정점(Vertex)와 간선(Edge)로 이루어짐. 노드와 노드를 연결하는 간선을 하나로 모아놓은 자료구조
- 간선(Edge)는 단방향, 양방향이 존재함.
- 정점을 연결하는 간선은 (A,B)처럼 정점 쌍으로 표현함

### 무방향 / 방향 그래프

- 무방향 그래프(Undirected Graph)와 방향 그래프(Directed Graph)가 존재함.
- 무방향 그래프는 간선을 통해서 양방향으로 이동 가능. (1,2)와 (2,1)은 동일함
- 방향 그래프의 경우 간선에 방향성이 존재한다. <A,B>로 표시하며, 이 경우 <A,B>와 <B,A>는 다름

### 가중치 그래프

- 간선에 비용이나 가중치가 할당된 그래프로, 네트워크라고도 한다.

![Untitled](https://user-images.githubusercontent.com/51450093/188319240-d0b9ae3d-9279-48f9-9d67-5ef2c8fdb311.png)

### 그래프의 구현

- 그래프는 인접 리스트(Adjacency List) 또는 인접행렬(Adjacency Matrix)로 구현한다.

  인접 리스트(Adjacency List)

![Untitled 1](https://user-images.githubusercontent.com/51450093/188319252-0858ecae-dbae-4c35-9c02-aa979722eb95.png)

인접 리스트 방식

- 인접 리스트 방식은 그래프의 노드를 리스트로 표현한 것으로, 노드들 간의 연결 관계가 있다면 해당 노드의 인덱스에 그 노드를 추가한다.
- 위의 경우 1번 노드는 2,3번 노드와 직접 연결되어 있기 때문에 해당 인덱스에 추가함
- 인접 리스트 방식은 정점들의 연결 정보를 탐색할 때 (O(n) n:노드 수 ) 만큼의 시간이 소요된다. 또한 필요한 만큼의 공간만 사용하기 때문에 공간효율적이다. 하지만 특정 두 점이 연결되어있는지 확인하려면 인접 행렬에 비해 시간이 오래 소요된다.(O(E) E: 간선의 수)

  인접행렬(Adjacency Matrix)

![Untitled 2](https://user-images.githubusercontent.com/51450093/188319264-d62567d6-2e36-4b99-a8e1-9d39c1067879.png)

- 그래프의 노드를 2차원 배열로 만든 것으로, 노드간의 연결관계가 있다면 1로, 아니면 0으로 표현한다
- 두 정점에 대한 연결 정보를 조회하기 위해 O(1)의 시간이 소요되며, 인접 리스트에 비해 구현이 쉽다
- 그래프에 존재하는 모든 간선의 수를 알기 위해 O(n^2)의 시간이 소요된다. 2차원 배열을 통해 구현하기 때문에 불필요한 공간이 생기게 되고, 공간 측면에서 효율적이지 않다.

## 트리(Tree)

![Untitled 3](https://user-images.githubusercontent.com/51450093/188471163-56d19da1-5f78-4c67-945a-57b5ea64efb8.png)

- 그래프의 일종으로, 계층적 관계(부모,자식 계층 구조)를 표현하는 자료구조이다.
- 노드와 간선으로 이루어진다. 루트 노드(root node), 리프 노드(leaf node)로 구성된다. 루트 노드는 부모가 없는 노드고, 리프 노드는 자식이 없는 노드이다.
- 루트 노드는 반드시 1개만 존재하며(최상단), 모든 자식 노드는 한개의 부모 노드만을 가진다.
- 간선 수 = 노드 수 - 1이다.
- 루트 노드부터 어떤 노드까지 가는 경로는 유일하다. 두 개의 노드 간에 반드시 하나의 경로만을 가진다.
- 트리의 높이는 루트 노드부터 리프 노드까지의 거리이며, 깊이는 루트 노드부터 특정 노드까지의 거리이다. 위 그림에서 G의 깊이는 2이다.
- 트리 내의 하위집합을 서브트리(Subtree)라고 한다.

### 이진 트리(Binary Tree)

- 각 노드가 최대 두개의 자식을 갖는 트리이다.

![Untitled 4](https://user-images.githubusercontent.com/51450093/188471214-a1b49cff-0cc2-4691-9fff-ed4aea62d4c2.png)

- In - order Traversal : 왼쪽 가지 → 현재 노드 → 오른쪽 가지. (ABCDEFGHI)
- Pre - order Traversal : 현재 노드 → 왼쪽 가지 → 오른쪽 가지 (FBADCEGIH)
- Post - order Traversal : 왼쪽 가지 → 오른쪽 가지 → 현재 노드 (ACEDBHIGF)

### 이진 탐색 트리(Binary Search Tree)

- 노드의 오른쪽 하위 트리에는 ‘노드 값보다 큰 값이 있는 노드만' 포함되고, 노드의 왼쪽 하위 트리에는 ‘노드 값보다 작은 값'이 들어있는 트리
- 검색에 용이한 자료구조이다.

![Untitled 5](https://user-images.githubusercontent.com/51450093/188471253-e0bdfbeb-06d3-4399-9b5b-f020617307d4.png)

- 어떤 요소를 찾기 위해 일반적으로 O(log n)의 시간이 소요된다.

![Untitled 6](https://user-images.githubusercontent.com/51450093/188471272-3e1a975e-856d-40e7-89da-49a5a8d7fd98.png)

- 위와 같이 선형적인 이진 탐색 트리가 형성되는 경우(최악의 경우), 탐색에 O(n)의 시간이 소요된다.

### 이진 트리의 종류

![Untitled 7](https://user-images.githubusercontent.com/51450093/188471299-6b7c7043-a538-41ca-9e93-57bfdf5c1324.png)

- 정이진 트리(Full Binary Tree) : 자식 노드가 0개 또는 2개인 트리
- 완전 이진 트리(Complete Binary Tree) : 왼쪽에서부터 채워져있는 이진 트리. 마지막 레벨을 제외하고는 모든 레벨이 전부 채워져 있으며, 마지막 레벨의 경우 왼쪽부터 채워져있음
- 포화 이진 트리(Perfect Binary Tree) : 모든 노드가 꽉 차 있는 이진 트리
-

### AVL트리

- 선형적인 이진 트리가 되는 것을 방지하고 스스로 균형을 잡는 이진 탐색 트리이다
- 탐색,삽입,삭제 모두 O(log n)의 시간복잡도를 가진다.
- 왼쪽 오른쪽 서브트리의 높이 차이가 최대 1이다. 높이 차이가 1보다 커지면 회전(Rotation)을 통해 높이 차이를 줄인다.
- Balanced Factor(BF) : AVL트리에서 균형을 판단하는 지표.
- BF(K) = K의 왼쪽 서브트리의 높이 - K의 오른쪽 서브트리의 높이

![Untitled 8](https://user-images.githubusercontent.com/51450093/188471332-0490d4a1-9fd0-47ba-9a27-16bbf7b5dd4e.png)

- AVL트리는 모든 노드의 BF가 -1,0,1 중 하나여야 한다.
- LL Rotation :

1. y노드의 오른쪽 자식 노드를 z노드로 변경합니다.
2. z노드 왼쪽 자식 노드를 y노드 오른쪽 서브트리(T2)로 변경합니다.
3. y는 새로운 루트 노드가 됩니다.

![Untitled 9](https://user-images.githubusercontent.com/51450093/188471361-597c7150-4b87-4a01-aa54-314726337ca6.png)

- LR Rotation : y는 z의 **왼쪽** 자식 노드이고, x는 y의 **오른쪽** 자식 노드인 경우 left , right 순으로 총 두 번의 rotation을 수행하여 균형을 맞춤

![Untitled 10](https://user-images.githubusercontent.com/51450093/188471390-431d7dd7-7ccd-4437-996d-aa8d8deeb9e1.png)

방향이 다른 경우(RR, RL) 에도 방향만 바꿔서 동일한 방식으로 회전

### 레드 블랙 트리

![Untitled 11](https://user-images.githubusercontent.com/51450093/188471416-1d1367e8-678d-4a84-8a39-70de02033976.png)

- 아래 조건을 만족하는 자가 균형 이진 탐색 트리이다.
- 삽입, 삭제, 탐색 모두 시간 복잡도가 O(log n)이다
- 모든 노드는 빨간색 또는 검은색이다.
- 루트 노드는 반드시 검은색이다.
- 모든 리프 노드는 검은색이다
- 빨간색 노드의 자식은 검은색이어야 한다. (빨간색 노드가 연속으로 나올 수 없다)
- 리프 노드에서 루트 노드까지 가는 경로에서 만나는 검은색 노드의 개수가 같다

## 힙(Heap)

![Untitled 12](https://user-images.githubusercontent.com/51450093/188471452-a1ec90ca-1e68-46e1-b95c-679e04dc3d96.png)

- 완전 이진 트리 기반의 자료구조로, 최소힙(Min heap)과 최대 힙(Max heap)이 존재한다.
- Min Heap : 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 최소값이어야 한다. 또한, 각 노드의 자식 노드와의 관계도 이와 같은 특징이 재귀적으로 이루어져야 한다.
- Max Heap : 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 최대값이어야 한다. 또한, 각 노드의 자식 노드와의 관계도 이와 같은 특징이 재귀적으로 이루어져야 한다.
- 힙에 새로운 요소를 삽입할 경우, 일단 새로운 노드를 마지막 노드에 이어서 삽입한 이후, 이 노드를 부모 노드들과 교환하며 힙의 성질을 만족시킨다.
- 힙에서 요소를 삭제하는 경우(최대 힙인 경우라고 치면) 루트 노드가 최대값이다. 루트 노드를 삭제한 후 힙의 마지막 노드를 대신 루트 노드 위치에 놓는다. 그 상태에서 자식 노드들과 값을 비교하며 힙의 성질을 만족시켜간다
-
